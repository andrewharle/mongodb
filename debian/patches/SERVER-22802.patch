Author: Andrew Harle <46223597+andrewharle@users.noreply.github.com>
Description: Merge upstream (3.3.3) patch [mongodb patch SERVER-22802].
	Resolves issue discovered during unit tests that causes a alignment exception.
	Without it error => [testsuite] Got signal: 7 (Bus error).... Received a StopExecution exception: DBTest jsobj failed.
Last-Update: 2019-01-02
Forwarded: no

--- a/src/mongo/bson/util/builder.h
+++ b/src/mongo/bson/util/builder.h
@@ -45,14 +45,7 @@
 #include "mongo/util/assert_util.h"
 
 namespace mongo {
-/* Accessing unaligned doubles on ARM generates an alignment trap and aborts with SIGBUS on Linux.
-   Wrapping the double in a packed struct forces gcc to generate code that works with unaligned
-   values too. The generated code for other architectures (which already allow unaligned accesses)
-   is the same as if there was a direct pointer access.
-*/
-struct PackedDouble {
-    double d;
-} PACKED_DECL;
+
 /* Note the limit here is rather arbitrary and is simply a standard. generally the code works
    with any object that fits in ram.
 
--- a/src/mongo/db/storage/mmap_v1/btree/key.cpp
+++ b/src/mongo/db/storage/mmap_v1/btree/key.cpp
@@ -32,6 +32,8 @@
 
 #include <cmath>
 
+#include "mongo/base/data_type_endian.h"
+#include "mongo/base/data_view.h"
 #include "mongo/bson/util/builder.h"
 #include "mongo/util/log.h"
 #include "mongo/util/startup_test.h"
@@ -315,7 +317,7 @@
             }
             case Date:
                 b.appendUChar(cdate | bits);
-                b.appendStruct(e.date());
+                b.appendNum(e.date().toMillisSinceEpoch());
                 break;
             case String: {
                 b.appendUChar(cstring | bits);
@@ -428,19 +430,28 @@
                 break;
             }
             case cdate:
-                b.appendDate("", (Date_t&)*p);
+                b.appendDate(
+                    "",
+                    Date_t::fromMillisSinceEpoch(ConstDataView(reinterpret_cast<const char*>(p))
+                                                     .read<LittleEndian<long long>>()));
                 p += 8;
                 break;
             case cdouble:
-                b.append("", (double&)*p);
+                b.append(
+                    "",
+                    ConstDataView(reinterpret_cast<const char*>(p)).read<LittleEndian<double>>());
                 p += sizeof(double);
                 break;
             case cint:
-                b.append("", static_cast<int>((reinterpret_cast<const PackedDouble&>(*p)).d));
+                b.append("",
+                         static_cast<int>(ConstDataView(reinterpret_cast<const char*>(p))
+                                              .read<LittleEndian<double>>()));
                 p += sizeof(double);
                 break;
             case clong:
-                b.append("", static_cast<long long>((reinterpret_cast<const PackedDouble&>(*p)).d));
+                b.append("",
+                         static_cast<long long>(ConstDataView(reinterpret_cast<const char*>(p))
+                                                    .read<LittleEndian<double>>()));
                 p += sizeof(double);
                 break;
             default:
@@ -466,8 +477,8 @@
     // same type
     switch (lt) {
         case cdouble: {
-            double L = (reinterpret_cast<const PackedDouble*>(l))->d;
-            double R = (reinterpret_cast<const PackedDouble*>(r))->d;
+            double L = ConstDataView(reinterpret_cast<const char*>(l)).read<LittleEndian<double>>();
+            double R = ConstDataView(reinterpret_cast<const char*>(r)).read<LittleEndian<double>>();
             if (L < R)
                 return -1;
             if (L != R)
@@ -518,8 +529,10 @@
             break;
         }
         case cdate: {
-            long long L = *((long long*)l);
-            long long R = *((long long*)r);
+            long long L =
+                ConstDataView(reinterpret_cast<const char*>(l)).read<LittleEndian<long long>>();
+            long long R =
+                ConstDataView(reinterpret_cast<const char*>(r)).read<LittleEndian<long long>>();
             if (L < R)
                 return -1;
             if (L > R)
@@ -648,19 +661,24 @@
         r++;
         switch (lval & cCANONTYPEMASK) {
             case coid:
-                if (*((unsigned*)l) != *((unsigned*)r))
+                if (ConstDataView(reinterpret_cast<const char*>(l))
+                        .read<LittleEndian<uint32_t>>() !=
+                    ConstDataView(reinterpret_cast<const char*>(r)).read<LittleEndian<uint32_t>>())
                     return false;
                 l += 4;
                 r += 4;
             case cdate:
-                if (*((unsigned long long*)l) != *((unsigned long long*)r))
+                if (ConstDataView(reinterpret_cast<const char*>(l))
+                        .read<LittleEndian<unsigned long long>>() !=
+                    ConstDataView(reinterpret_cast<const char*>(r))
+                        .read<LittleEndian<unsigned long long>>())
                     return false;
                 l += 8;
                 r += 8;
                 break;
             case cdouble:
-                if ((reinterpret_cast<const PackedDouble*>(l))->d !=
-                    (reinterpret_cast<const PackedDouble*>(r))->d)
+                if (ConstDataView(reinterpret_cast<const char*>(l)).read<LittleEndian<double>>() !=
+                    ConstDataView(reinterpret_cast<const char*>(r)).read<LittleEndian<double>>())
                     return false;
                 l += 8;
                 r += 8;
