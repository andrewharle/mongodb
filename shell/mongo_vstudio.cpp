const char * jsconcatcode = 
"__quiet = false;\n"
 "__magicNoPrint = { __magicNoPrint : 1111 }\n"
 "chatty = function(s){\n"
 "if ( ! __quiet )\n"
 "print( s );}\n"
 "friendlyEqual = function( a , b ){\n"
 "if ( a == b )\n"
 "return true;\n"
 "if ( tojson( a ) == tojson( b ) )\n"
 "return true;\n"
 "return false;}\n"
 "doassert = function (msg) {\n"
 "if (msg.indexOf(\"assert\") == 0)\n"
 "print(msg);\n"
 "else\n"
 "print(\"assert: \" + msg);\n"
 "throw msg;}\n"
 "assert = function( b , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( b )\n"
 "return;\n"
 "doassert( msg == undefined ? \"assert failed\" : \"assert failed : \" + msg );}\n"
 "assert.automsg = function( b ) {\n"
 "assert( eval( b ), b );}\n"
 "assert._debug = false;\n"
 "assert.eq = function( a , b , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( a == b )\n"
 "return;\n"
 "if ( ( a != null && b != null ) && friendlyEqual( a , b ) )\n"
 "return;\n"
 "doassert( \"[\" + tojson( a ) + \"] != [\" + tojson( b ) + \"] are not equal : \" + msg );}\n"
 "assert.eq.automsg = function( a, b ) {\n"
 "assert.eq( eval( a ), eval( b ), \"[\" + a + \"] != [\" + b + \"]\" );}\n"
 "assert.neq = function( a , b , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( a != b )\n"
 "return;\n"
 "doassert( \"[\" + a + \"] != [\" + b + \"] are equal : \" + msg );}\n"
 "assert.repeat = function( f, msg, timeout, interval ) {\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "var start = new Date();\n"
 "timeout = timeout || 30000;\n"
 "interval = interval || 200;\n"
 "var last;\n"
 "while( 1 ) {\n"
 "if ( typeof( f ) == \"string\" ){\n"
 "if ( eval( f ) )\n"
 "return;}\n"
 "else {\n"
 "if ( f() )\n"
 "return;}\n"
 "if ( ( new Date() ).getTime() - start.getTime() > timeout )\n"
 "break;\n"
 "sleep( interval );}}\n"
 "assert.soon = function( f, msg, timeout, interval ) {\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "var start = new Date();\n"
 "timeout = timeout || 30000;\n"
 "interval = interval || 200;\n"
 "var last;\n"
 "while( 1 ) {\n"
 "if ( typeof( f ) == \"string\" ){\n"
 "if ( eval( f ) )\n"
 "return;}\n"
 "else {\n"
 "if ( f() )\n"
 "return;}\n"
 "if ( ( new Date() ).getTime() - start.getTime() > timeout )\n"
 "doassert( \"assert.soon failed: \" + f + \", msg:\" + msg );\n"
 "sleep( interval );}}\n"
 "assert.throws = function( func , params , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "try {\n"
 "func.apply( null , params );}\n"
 "catch ( e ){\n"
 "return e;}\n"
 "doassert( \"did not throw exception: \" + msg );}\n"
 "assert.throws.automsg = function( func, params ) {\n"
 "assert.throws( func, params, func.toString() );}\n"
 "assert.commandWorked = function( res , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( res.ok == 1 )\n"
 "return;\n"
 "doassert( \"command failed: \" + tojson( res ) + \" : \" + msg );}\n"
 "assert.commandFailed = function( res , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( res.ok == 0 )\n"
 "return;\n"
 "doassert( \"command worked when it should have failed: \" + tojson( res ) + \" : \" + msg );}\n"
 "assert.isnull = function( what , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( what == null )\n"
 "return;\n"
 "doassert( \"supposed to null (\" + ( msg || \"\" ) + \") was: \" + tojson( what ) );}\n"
 "assert.lt = function( a , b , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( a < b )\n"
 "return;\n"
 "doassert( a + \" is not less than \" + b + \" : \" + msg );}\n"
 "assert.gt = function( a , b , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( a > b )\n"
 "return;\n"
 "doassert( a + \" is not greater than \" + b + \" : \" + msg );}\n"
 "assert.lte = function( a , b , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( a <= b )\n"
 "return;\n"
 "doassert( a + \" is not less than or eq \" + b + \" : \" + msg );}\n"
 "assert.gte = function( a , b , msg ){\n"
 "if ( assert._debug && msg ) print( \"in assert for: \" + msg );\n"
 "if ( a >= b )\n"
 "return;\n"
 "doassert( a + \" is not greater than or eq \" + b + \" : \" + msg );}\n"
 "assert.close = function( a , b , msg , places ){\n"
 "if (places === undefined) {\n"
 "places = 4;}\n"
 "if (Math.round((a - b) * Math.pow(10, places)) === 0) {\n"
 "return;}\n"
 "doassert( a + \" is not equal to \" + b + \" within \" + places +\n"
 "\" places, diff: \" + (a-b) + \" : \" + msg );\n"
 "};\n"
 "Object.extend = function( dst , src , deep ){\n"
 "for ( var k in src ){\n"
 "var v = src[k];\n"
 "if ( deep && typeof(v) == \"object\" ){\n"
 "v = Object.extend( typeof ( v.length ) == \"number\" ? [] : {} , v , true );}\n"
 "dst[k] = v;}\n"
 "return dst;}\n"
 "argumentsToArray = function( a ){\n"
 "var arr = [];\n"
 "for ( var i=0; i<a.length; i++ )\n"
 "arr[i] = a[i];\n"
 "return arr;}\n"
 "isString = function( x ){\n"
 "return typeof( x ) == \"string\";}\n"
 "isNumber = function(x){\n"
 "return typeof( x ) == \"number\";}\n"
 "isObject = function( x ){\n"
 "return typeof( x ) == \"object\";}\n"
 "String.prototype.trim = function() {\n"
 "return this.replace(/^\\s+|\\s+$/g,\"\");}\n"
 "String.prototype.ltrim = function() {\n"
 "return this.replace(/^\\s+/,\"\");}\n"
 "String.prototype.rtrim = function() {\n"
 "return this.replace(/\\s+$/,\"\");}\n"
 "Date.timeFunc = function( theFunc , numTimes ){\n"
 "var start = new Date();\n"
 "numTimes = numTimes || 1;\n"
 "for ( var i=0; i<numTimes; i++ ){\n"
 "theFunc.apply( null , argumentsToArray( arguments ).slice( 2 ) );}\n"
 "return (new Date()).getTime() - start.getTime();}\n"
 "Date.prototype.tojson = function(){\n"
 "return \"\\\"\" + this.toString() + \"\\\"\";}\n"
 "RegExp.prototype.tojson = RegExp.prototype.toString;\n"
 "Array.contains = function( a  , x ){\n"
 "for ( var i=0; i<a.length; i++ ){\n"
 "if ( a[i] == x )\n"
 "return true;}\n"
 "return false;}\n"
 "Array.unique = function( a ){\n"
 "var u = [];\n"
 "for ( var i=0; i<a.length; i++){\n"
 "var o = a[i];\n"
 "if ( ! Array.contains( u , o ) ){\n"
 "u.push( o );}}\n"
 "return u;}\n"
 "Array.shuffle = function( arr ){\n"
 "for ( var i=0; i<arr.length-1; i++ ){\n"
 "var pos = i+Random.randInt(arr.length-i);\n"
 "var save = arr[i];\n"
 "arr[i] = arr[pos];\n"
 "arr[pos] = save;}\n"
 "return arr;}\n"
 "Array.tojson = function( a , indent ){\n"
 "if (!indent)\n"
 "indent = \"\";\n"
 "if (a.length == 0) {\n"
 "return \"[ ]\";}\n"
 "var s = \"[\\n\";\n"
 "indent += \"\\t\";\n"
 "for ( var i=0; i<a.length; i++){\n"
 "s += indent + tojson( a[i], indent );\n"
 "if ( i < a.length - 1 ){\n"
 "s += \",\\n\";}}\n"
 "if ( a.length == 0 ) {\n"
 "s += indent;}\n"
 "indent = indent.substring(1);\n"
 "s += \"\\n\"+indent+\"]\";\n"
 "return s;}\n"
 "Array.fetchRefs = function( arr , coll ){\n"
 "var n = [];\n"
 "for ( var i=0; i<arr.length; i ++){\n"
 "var z = arr[i];\n"
 "if ( coll && coll != z.getCollection() )\n"
 "continue;\n"
 "n.push( z.fetch() );}\n"
 "return n;}\n"
 "Array.sum = function( arr ){\n"
 "if ( arr.length == 0 )\n"
 "return null;\n"
 "var s = arr[0];\n"
 "for ( var i=1; i<arr.length; i++ )\n"
 "s += arr[i];\n"
 "return s;}\n"
 "Array.avg = function( arr ){\n"
 "if ( arr.length == 0 )\n"
 "return null;\n"
 "return Array.sum( arr ) / arr.length;}\n"
 "Array.stdDev = function( arr ){\n"
 "var avg = Array.avg( arr );\n"
 "var sum = 0;\n"
 "for ( var i=0; i<arr.length; i++ ){\n"
 "sum += Math.pow( arr[i] - avg , 2 );}\n"
 "return Math.sqrt( sum / arr.length );}\n"
 "Object.keySet = function( o ) {\n"
 "var ret = new Array();\n"
 "for( i in o ) {\n"
 "if ( !( i in o.__proto__ && o[ i ] === o.__proto__[ i ] ) ) {\n"
 "ret.push( i );}}\n"
 "return ret;}\n"
 "if ( ! NumberLong.prototype ) {\n"
 "NumberLong.prototype = {}}\n"
 "NumberLong.prototype.tojson = function() {\n"
 "return this.toString();}\n"
 "if ( ! ObjectId.prototype )\n"
 "ObjectId.prototype = {}\n"
 "ObjectId.prototype.toString = function(){\n"
 "return this.str;}\n"
 "ObjectId.prototype.tojson = function(){\n"
 "return \"ObjectId(\\\"\" + this.str + \"\\\")\";}\n"
 "ObjectId.prototype.isObjectId = true;\n"
 "ObjectId.prototype.getTimestamp = function(){\n"
 "return new Date(parseInt(this.toString().slice(0,8), 16)*1000);}\n"
 "ObjectId.prototype.equals = function( other){\n"
 "return this.str == other.str;}\n"
 "if ( typeof( DBPointer ) != \"undefined\" ){\n"
 "DBPointer.prototype.fetch = function(){\n"
 "assert( this.ns , \"need a ns\" );\n"
 "assert( this.id , \"need an id\" );\n"
 "return db[ this.ns ].findOne( { _id : this.id } );}\n"
 "DBPointer.prototype.tojson = function(indent){\n"
 "return tojson({\"ns\" : this.ns, \"id\" : this.id}, indent);}\n"
 "DBPointer.prototype.getCollection = function(){\n"
 "return this.ns;}\n"
 "DBPointer.prototype.toString = function(){\n"
 "return \"DBPointer \" + this.ns + \":\" + this.id;}}\n"
 "else {\n"
 "print( \"warning: no DBPointer\" );}\n"
 "if ( typeof( DBRef ) != \"undefined\" ){\n"
 "DBRef.prototype.fetch = function(){\n"
 "assert( this.$ref , \"need a ns\" );\n"
 "assert( this.$id , \"need an id\" );\n"
 "return db[ this.$ref ].findOne( { _id : this.$id } );}\n"
 "DBRef.prototype.tojson = function(indent){\n"
 "return tojson({\"$ref\" : this.$ref, \"$id\" : this.$id}, indent);}\n"
 "DBRef.prototype.getCollection = function(){\n"
 "return this.$ref;}\n"
 "DBRef.prototype.toString = function(){\n"
 "return this.tojson();}}\n"
 "else {\n"
 "print( \"warning: no DBRef\" );}\n"
 "if ( typeof( BinData ) != \"undefined\" ){\n"
 "BinData.prototype.tojson = function () {\n"
 "//return \"BinData type: \" + this.type + \" len: \" + this.len;\n"
 "return this.toString();}}\n"
 "else {\n"
 "print( \"warning: no BinData class\" );}\n"
 "if ( typeof( UUID ) != \"undefined\" ){\n"
 "UUID.prototype.tojson = function () {\n"
 "return this.toString();}}\n"
 "if ( typeof _threadInject != \"undefined\" ){\n"
 "print( \"fork() available!\" );\n"
 "Thread = function(){\n"
 "this.init.apply( this, arguments );}\n"
 "_threadInject( Thread.prototype );\n"
 "ScopedThread = function() {\n"
 "this.init.apply( this, arguments );}\n"
 "ScopedThread.prototype = new Thread( function() {} );\n"
 "_scopedThreadInject( ScopedThread.prototype );\n"
 "fork = function() {\n"
 "var t = new Thread( function() {} );\n"
 "Thread.apply( t, arguments );\n"
 "return t;}\n"
 "EventGenerator = function( me, collectionName, mean ) {\n"
 "this.mean = mean;\n"
 "this.events = new Array( me, collectionName );}\n"
 "EventGenerator.prototype._add = function( action ) {\n"
 "this.events.push( [ Random.genExp( this.mean ), action ] );}\n"
 "EventGenerator.prototype.addInsert = function( obj ) {\n"
 "this._add( \"t.insert( \" + tojson( obj ) + \" )\" );}\n"
 "EventGenerator.prototype.addRemove = function( obj ) {\n"
 "this._add( \"t.remove( \" + tojson( obj ) + \" )\" );}\n"
 "EventGenerator.prototype.addUpdate = function( objOld, objNew ) {\n"
 "this._add( \"t.update( \" + tojson( objOld ) + \", \" + tojson( objNew ) + \" )\" );}\n"
 "EventGenerator.prototype.addCheckCount = function( count, query, shouldPrint, checkQuery ) {\n"
 "query = query || {};\n"
 "shouldPrint = shouldPrint || false;\n"
 "checkQuery = checkQuery || false;\n"
 "var action = \"assert.eq( \" + count + \", t.count( \" + tojson( query ) + \" ) );\"\n"
 "if ( checkQuery ) {\n"
 "action += \" assert.eq( \" + count + \", t.find( \" + tojson( query ) + \" ).toArray().length );\"}\n"
 "if ( shouldPrint ) {\n"
 "action += \" print( me + ' ' + \" + count + \" );\";}\n"
 "this._add( action );}\n"
 "EventGenerator.prototype.getEvents = function() {\n"
 "return this.events;}\n"
 "EventGenerator.dispatch = function() {\n"
 "var args = argumentsToArray( arguments );\n"
 "var me = args.shift();\n"
 "var collectionName = args.shift();\n"
 "var m = new Mongo( db.getMongo().host );\n"
 "var t = m.getDB( \"test\" )[ collectionName ];\n"
 "for( var i in args ) {\n"
 "sleep( args[ i ][ 0 ] );\n"
 "eval( args[ i ][ 1 ] );}}\n"
 "ParallelTester = function() {\n"
 "this.params = new Array();}\n"
 "ParallelTester.prototype.add = function( fun, args ) {\n"
 "args = args || [];\n"
 "args.unshift( fun );\n"
 "this.params.push( args );}\n"
 "ParallelTester.prototype.run = function( msg, newScopes ) {\n"
 "newScopes = newScopes || false;\n"
 "assert.parallelTests( this.params, msg, newScopes );}\n"
 "ParallelTester.createJstestsLists = function( n ) {\n"
 "var params = new Array();\n"
 "for( var i = 0; i < n; ++i ) {\n"
 "params.push( [] );}\n"
 "var makeKeys = function( a ) {\n"
 "var ret = {};\n"
 "for( var i in a ) {\n"
 "ret[ a[ i ] ] = 1;}\n"
 "return ret;}\n"
 "var skipTests = makeKeys( [ \"jstests/dbadmin.js\",\n"
 "\"jstests/repair.js\",\n"
 "\"jstests/cursor8.js\",\n"
 "\"jstests/recstore.js\",\n"
 "\"jstests/extent.js\",\n"
 "\"jstests/indexb.js\",\n"
 "\"jstests/profile1.js\",\n"
 "\"jstests/mr3.js\",\n"
 "\"jstests/indexh.js\",\n"
 "\"jstests/apitest_db.js\",\n"
 "\"jstests/evalb.js\"] );\n"
 "var serialTestsArr = [ \"jstests/fsync.js\",\n"
 "\"jstests/fsync2.js\" ];\n"
 "var serialTests = makeKeys( serialTestsArr );\n"
 "params[ 0 ] = serialTestsArr;\n"
 "var files = listFiles(\"jstests\");\n"
 "files = Array.shuffle( files );\n"
 "var i = 0;\n"
 "files.forEach(\n"
 "function(x) {\n"
 "if ( ( /[\\/\\\\]_/.test(x.name) ) ||\n"
 "( ! /\\.js$/.test(x.name ) ) ||\n"
 "( x.name in skipTests ) ||\n"
 "( x.name in serialTests ) ||\n"
 "! /\\.js$/.test(x.name ) ){\n"
 "print(\" >>>>>>>>>>>>>>> skipping \" + x.name);\n"
 "return;}\n"
 "params[ i % n ].push( x.name );\n"
 "++i;}\n"
 ");\n"
 "params[ 0 ] = Array.shuffle( params[ 0 ] );\n"
 "for( var i in params ) {\n"
 "params[ i ].unshift( i );}\n"
 "return params;}\n"
 "ParallelTester.fileTester = function() {\n"
 "var args = argumentsToArray( arguments );\n"
 "var suite = args.shift();\n"
 "args.forEach(\n"
 "function( x ) {\n"
 "print(\"         S\" + suite + \" Test : \" + x + \" ...\");\n"
 "var time = Date.timeFunc( function() { load(x); }, 1);\n"
 "print(\"         S\" + suite + \" Test : \" + x + \" \" + time + \"ms\" );}\n"
 ");}\n"
 "assert.parallelTests = function( params, msg, newScopes ) {\n"
 "newScopes = newScopes || false;\n"
 "var wrapper = function( fun, argv ) {\n"
 "eval (\n"
 "\"var z = function() {\" +\n"
 "\"var __parallelTests__fun = \" + fun.toString() + \";\" +\n"
 "\"var __parallelTests__argv = \" + tojson( argv ) + \";\" +\n"
 "\"var __parallelTests__passed = false;\" +\n"
 "\"try {\" +\n"
 "\"__parallelTests__fun.apply( 0, __parallelTests__argv );\" +\n"
 "\"__parallelTests__passed = true;\" +\n"
 "\"} catch ( e ) {\" +\n"
 "\"print( e );\" +\n"
 "\"}\" +\n"
 "\"return __parallelTests__passed;\" +\n"
 "\"}\"\n"
 ");\n"
 "return z;}\n"
 "var runners = new Array();\n"
 "for( var i in params ) {\n"
 "var param = params[ i ];\n"
 "var test = param.shift();\n"
 "var t;\n"
 "if ( newScopes )\n"
 "t = new ScopedThread( wrapper( test, param ) );\n"
 "else\n"
 "t = new Thread( wrapper( test, param ) );\n"
 "runners.push( t );}\n"
 "runners.forEach( function( x ) { x.start(); } );\n"
 "var nFailed = 0;\n"
 "runners.forEach( function( x ) { if( !x.returnData() ) { ++nFailed; } } );\n"
 "assert.eq( 0, nFailed, msg );}}\n"
 "tojsononeline = function( x ){\n"
 "return tojson( x , \" \" , true );}\n"
 "tojson = function( x, indent , nolint ){\n"
 "if ( x === null )\n"
 "return \"null\";\n"
 "if ( x === undefined )\n"
 "return \"undefined\";\n"
 "if (!indent)\n"
 "indent = \"\";\n"
 "switch ( typeof x ) {\n"
 "case \"string\": {\n"
 "var s = \"\\\"\";\n"
 "for ( var i=0; i<x.length; i++ ){\n"
 "switch (x[i]){\n"
 "case '\"': s += '\\\\\"'; break;\n"
 "case '\\\\': s += '\\\\\\\\'; break;\n"
 "case '\\b': s += '\\\\b'; break;\n"
 "case '\\f': s += '\\\\f'; break;\n"
 "case '\\n': s += '\\\\n'; break;\n"
 "case '\\r': s += '\\\\r'; break;\n"
 "case '\\t': s += '\\\\t'; break;\n"
 "default: {\n"
 "var code = x.charCodeAt(i);\n"
 "if (code < 0x20){\n"
 "s += (code < 0x10 ? '\\\\u000' : '\\\\u00') + code.toString(16);\n"
 "} else {\n"
 "s += x[i];}}}}\n"
 "return s + \"\\\"\";}\n"
 "case \"number\":\n"
 "case \"boolean\":\n"
 "return \"\" + x;\n"
 "case \"object\":{\n"
 "var s = tojsonObject( x, indent , nolint );\n"
 "if ( ( nolint == null || nolint == true ) && s.length < 80 && ( indent == null || indent.length == 0 ) ){\n"
 "s = s.replace( /[\\s\\r\\n ]+/gm , \" \" );}\n"
 "return s;}\n"
 "case \"function\":\n"
 "return x.toString();\n"
 "default:\n"
 "throw \"tojson can't handle type \" + ( typeof x );}}\n"
 "tojsonObject = function( x, indent , nolint ){\n"
 "var lineEnding = nolint ? \" \" : \"\\n\";\n"
 "var tabSpace = nolint ? \"\" : \"\\t\";\n"
 "assert.eq( ( typeof x ) , \"object\" , \"tojsonObject needs object, not [\" + ( typeof x ) + \"]\" );\n"
 "if (!indent)\n"
 "indent = \"\";\n"
 "if ( typeof( x.tojson ) == \"function\" && x.tojson != tojson ) {\n"
 "return x.tojson(indent,nolint);}\n"
 "if ( x.constructor && typeof( x.constructor.tojson ) == \"function\" && x.constructor.tojson != tojson ) {\n"
 "return x.constructor.tojson( x, indent , nolint );}\n"
 "if ( x.toString() == \"[object MaxKey]\" )\n"
 "return \"{ $maxKey : 1 }\";\n"
 "if ( x.toString() == \"[object MinKey]\" )\n"
 "return \"{ $minKey : 1 }\";\n"
 "var s = \"{\" + lineEnding;\n"
 "indent += tabSpace;\n"
 "var total = 0;\n"
 "for ( var k in x ) total++;\n"
 "if ( total == 0 ) {\n"
 "s += indent + lineEnding;}\n"
 "var keys = x;\n"
 "if ( typeof( x._simpleKeys ) == \"function\" )\n"
 "keys = x._simpleKeys();\n"
 "var num = 1;\n"
 "for ( var k in keys ){\n"
 "var val = x[k];\n"
 "if ( val == DB.prototype || val == DBCollection.prototype )\n"
 "continue;\n"
 "s += indent + \"\\\"\" + k + \"\\\" : \" + tojson( val, indent , nolint );\n"
 "if (num != total) {\n"
 "s += \",\";\n"
 "num++;}\n"
 "s += lineEnding;}\n"
 "indent = indent.substring(1);\n"
 "return s + indent + \"}\";}\n"
 "shellPrint = function( x ){\n"
 "it = x;\n"
 "if ( x != undefined )\n"
 "shellPrintHelper( x );\n"
 "if ( db ){\n"
 "var e = db.getPrevError();\n"
 "if ( e.err ) {\n"
 "if( e.nPrev <= 1 )\n"
 "print( \"error on last call: \" + tojson( e.err ) );\n"
 "else\n"
 "print( \"an error \" + tojson(e.err) + \" occurred \" + e.nPrev + \" operations back in the command invocation\" );}\n"
 "db.resetError();}}\n"
 "printjson = function(x){\n"
 "print( tojson( x ) );}\n"
 "printjsononeline = function(x){\n"
 "print( tojsononeline( x ) );}\n"
 "shellPrintHelper = function( x ){\n"
 "if ( typeof( x ) == \"undefined\" ){\n"
 "if ( typeof( db ) != \"undefined\" && db.getLastError ){\n"
 "var e = db.getLastError();\n"
 "if ( e != null )\n"
 "print( e );}\n"
 "return;}\n"
 "if ( x == __magicNoPrint )\n"
 "return;\n"
 "if ( x == null ){\n"
 "print( \"null\" );\n"
 "return;}\n"
 "if ( typeof x != \"object\" )\n"
 "return print( x );\n"
 "var p = x.shellPrint;\n"
 "if ( typeof p == \"function\" )\n"
 "return x.shellPrint();\n"
 "var p = x.tojson;\n"
 "if ( typeof p == \"function\" )\n"
 "print( x.tojson() );\n"
 "else\n"
 "print( tojson( x ) );}\n"
 "shellAutocomplete = function( prefix ){\n"
 "var a = [];\n"
 "//a.push( prefix + \"z\" )\n"
 "//a.push( prefix + \"y\" )\n"
 "__autocomplete__ = a;}\n"
 "shellHelper = function( command , rest , shouldPrint ){\n"
 "command = command.trim();\n"
 "var args = rest.trim().replace(/;$/,\"\").split( \"\\s+\" );\n"
 "if ( ! shellHelper[command] )\n"
 "throw \"no command [\" + command + \"]\";\n"
 "var res = shellHelper[command].apply( null , args );\n"
 "if ( shouldPrint ){\n"
 "shellPrintHelper( res );}\n"
 "return res;}\n"
 "shellHelper.use = function( dbname ){\n"
 "db = db.getMongo().getDB( dbname );\n"
 "print( \"switched to db \" + db.getName() );}\n"
 "shellHelper.it = function(){\n"
 "if ( typeof( ___it___ ) == \"undefined\" || ___it___ == null ){\n"
 "print( \"no cursor\" );\n"
 "return;}\n"
 "shellPrintHelper( ___it___ );}\n"
 "shellHelper.show = function( what ){\n"
 "assert( typeof what == \"string\" );\n"
 "if( what == \"profile\" ) {\n"
 "if( db.system.profile.count() == 0 ) {\n"
 "print(\"db.system.profile is empty\");\n"
 "print(\"Use db.setProfilingLevel(2) will enable profiling\");\n"
 "print(\"Use db.system.profile.find() to show raw profile entries\");}\n"
 "else {\n"
 "print();\n"
 "db.system.profile.find({ millis : { $gt : 0 } }).sort({$natural:-1}).limit(5).forEach( function(x){print(\"\"+x.millis+\"ms \" + String(x.ts).substring(0,24)); print(x.info); print(\"\\n\");} )}\n"
 "return \"\";}\n"
 "if ( what == \"users\" ){\n"
 "db.system.users.find().forEach( printjson );\n"
 "return \"\";}\n"
 "if ( what == \"collections\" || what == \"tables\" ) {\n"
 "db.getCollectionNames().forEach( function(x){print(x)} );\n"
 "return \"\";}\n"
 "if ( what == \"dbs\" ) {\n"
 "db.getMongo().getDBNames().sort().forEach( function(x){print(x)} );\n"
 "return \"\";}\n"
 "throw \"don't know how to show [\" + what + \"]\";}\n"
 "if ( typeof( Map ) == \"undefined\" ){\n"
 "Map = function(){\n"
 "this._data = {};}}\n"
 "Map.hash = function( val ){\n"
 "if ( ! val )\n"
 "return val;\n"
 "switch ( typeof( val ) ){\n"
 "case 'string':\n"
 "case 'number':\n"
 "case 'date':\n"
 "return val.toString();\n"
 "case 'object':\n"
 "case 'array':\n"
 "var s = \"\";\n"
 "for ( var k in val ){\n"
 "s += k + val[k];}\n"
 "return s;}\n"
 "throw \"can't hash : \" + typeof( val );}\n"
 "Map.prototype.put = function( key , value ){\n"
 "var o = this._get( key );\n"
 "var old = o.value;\n"
 "o.value = value;\n"
 "return old;}\n"
 "Map.prototype.get = function( key ){\n"
 "return this._get( key ).value;}\n"
 "Map.prototype._get = function( key ){\n"
 "var h = Map.hash( key );\n"
 "var a = this._data[h];\n"
 "if ( ! a ){\n"
 "a = [];\n"
 "this._data[h] = a;}\n"
 "for ( var i=0; i<a.length; i++ ){\n"
 "if ( friendlyEqual( key , a[i].key ) ){\n"
 "return a[i];}}\n"
 "var o = { key : key , value : null };\n"
 "a.push( o );\n"
 "return o;}\n"
 "Map.prototype.values = function(){\n"
 "var all = [];\n"
 "for ( var k in this._data ){\n"
 "this._data[k].forEach( function(z){ all.push( z.value ); } );}\n"
 "return all;}\n"
 "if ( typeof( gc ) == \"undefined\" ){\n"
 "gc = function(){\n"
 "print( \"warning: using noop gc()\" );}}\n"
 "Math.sigFig = function( x , N ){\n"
 "if ( ! N ){\n"
 "N = 3;}\n"
 "var p = Math.pow( 10, N - Math.ceil( Math.log( Math.abs(x) ) / Math.log( 10 )) );\n"
 "return Math.round(x*p)/p;}\n"
 "Random = function() {}\n"
 "Random.srand = function( s ) { _srand( s ); }\n"
 "Random.rand = function() { return _rand(); }\n"
 "Random.randInt = function( n ) { return Math.floor( Random.rand() * n ); }\n"
 "Random.setRandomSeed = function( s ) {\n"
 "s = s || new Date().getTime();\n"
 "print( \"setting random seed: \" + s );\n"
 "Random.srand( s );}\n"
 "Random.genExp = function( mean ) {\n"
 "return -Math.log( Random.rand() ) * mean;}\n"
 "killWithUris = function( uris ) {\n"
 "var inprog = db.currentOp().inprog;\n"
 "for( var u in uris ) {\n"
 "for ( var i in inprog ) {\n"
 "if ( uris[ u ] == inprog[ i ].client ) {\n"
 "db.killOp( inprog[ i ].opid );}}}}\n"
 "Geo = {};\n"
 "Geo.distance = function( a , b ){\n"
 "var ax = null;\n"
 "var ay = null;\n"
 "var bx = null;\n"
 "var by = null;\n"
 "for ( var key in a ){\n"
 "if ( ax == null )\n"
 "ax = a[key];\n"
 "else if ( ay == null )\n"
 "ay = a[key];}\n"
 "for ( var key in b ){\n"
 "if ( bx == null )\n"
 "bx = b[key];\n"
 "else if ( by == null )\n"
 "by = b[key];}\n"
 "return Math.sqrt( Math.pow( by - ay , 2 ) +\n"
 "Math.pow( bx - ax , 2 ) );}\n"
 "rs = function () { return \"try rs.help()\"; }\n"
 "rs.help = function () {\n"
 "print(\"\\trs.status()                     { replSetGetStatus : 1 } checks repl set status\");\n"
 "print(\"\\trs.initiate()                   { replSetInitiate : null } initiates set with default settings\");\n"
 "print(\"\\trs.initiate(cfg)                { replSetInitiate : cfg } initiates set with configuration cfg\");\n"
 "print(\"\\trs.add(hostportstr)             add a new member to the set with default attributes\");\n"
 "print(\"\\trs.add(membercfgobj)            add a new member to the set with extra attributes\");\n"
 "print(\"\\trs.addArb(hostportstr)          add a new member which is arbiterOnly:true\");\n"
 "print(\"\\trs.stepDown()                   step down as primary (momentarily)\");\n"
 "print(\"\\trs.conf()                       return configuration from local.system.replset\");\n"
 "print(\"\\trs.slaveOk()                    shorthand for db.getMongo().setSlaveOk()\");\n"
 "print();\n"
 "print(\"\\tdb.isMaster()                   check who is primary\");\n"
 "print();\n"
 "print(\"\\tsee also http://<mongod_host>:28017/_replSet for additional diagnostic info\");}\n"
 "rs.slaveOk = function () { return db.getMongo().setSlaveOk(); }\n"
 "rs.status = function () { return db._adminCommand(\"replSetGetStatus\"); }\n"
 "rs.isMaster = function () { return db.isMaster(); }\n"
 "rs.initiate = function (c) { return db._adminCommand({ replSetInitiate: c }); }\n"
 "rs.add = function (hostport, arb) {\n"
 "var cfg = hostport;\n"
 "var local = db.getSisterDB(\"local\");\n"
 "assert(local.system.replset.count() <= 1, \"error: local.system.replset has unexpected contents\");\n"
 "var c = local.system.replset.findOne();\n"
 "assert(c, \"no config object retrievable from local.system.replset\");\n"
 "c.version++;\n"
 "var max = 0;\n"
 "for (var i in c.members)\n"
 "if (c.members[i]._id > max) max = c.members[i]._id;\n"
 "if (isString(hostport)) {\n"
 "cfg = { _id: max + 1, host: hostport };\n"
 "if (arb)\n"
 "cfg.arbiterOnly = true;}\n"
 "c.members.push(cfg);\n"
 "return db._adminCommand({ replSetReconfig: c });}\n"
 "rs.stepDown = function () { return db._adminCommand({ replSetStepDown:true}); }\n"
 "rs.addArb = function (hn) { return this.add(hn, true); }\n"
 "rs.conf = function () { return db.getSisterDB(\"local\").system.replset.findOne(); }\n"
 "help = shellHelper.help = function (x) {\n"
 "if (x == \"connect\") {\n"
 "print(\"\\nNormally one specifies the server on the mongo shell command line.  Run mongo --help to see those options.\");\n"
 "print(\"Additional connections may be opened:\\n\");\n"
 "print(\"    var x = new Mongo('host[:port]');\");\n"
 "print(\"    var mydb = x.getDB('mydb');\");\n"
 "print(\"  or\");\n"
 "print(\"    var mydb = connect('host[:port]/mydb');\");\n"
 "print(\"\\nNote: the REPL prompt only auto-reports getLastError() for the shell command line connection.\\n\");\n"
 "return;}\n"
 "if (x == \"misc\") {\n"
 "print(\"\\tb = new BinData(subtype,base64str)  create a BSON BinData value\");\n"
 "print(\"\\tb.subtype()                         the BinData subtype (0..255)\");\n"
 "print(\"\\tb.length()                          length of the BinData data in bytes\");\n"
 "print(\"\\tb.hex()                             the data as a hex encoded string\");\n"
 "print(\"\\tb.base64()                          the data as a base 64 encoded string\");\n"
 "print(\"\\tb.toString()\");\n"
 "return;}\n"
 "if (x == \"admin\") {\n"
 "print(\"\\tls([path])                      list files\");\n"
 "print(\"\\tpwd()                           returns current directory\");\n"
 "print(\"\\tlistFiles([path])               returns file list\");\n"
 "print(\"\\thostname()                      returns name of this host\");\n"
 "print(\"\\tcat(fname)                      returns contents of text file as a string\");\n"
 "print(\"\\tremoveFile(f)                   delete a file\");\n"
 "print(\"\\tload(jsfilename)                load and execute a .js file\");\n"
 "print(\"\\trun(program[, args...])         spawn a program and wait for its completion\");\n"
 "print(\"\\tsleep(m)                        sleep m milliseconds\");\n"
 "print(\"\\tgetMemInfo()                    diagnostic\");\n"
 "return;}\n"
 "if (x == \"test\") {\n"
 "print(\"\\tstartMongodEmpty(args)        DELETES DATA DIR and then starts mongod\");\n"
 "print(\"\\t                              returns a connection to the new server\");\n"
 "print(\"\\tstartMongodTest()             DELETES DATA DIR\");\n"
 "print(\"\\t                              automatically picks port #s starting at 27000 and increasing\");\n"
 "print(\"\\t                              or you can specify the port as the first arg\");\n"
 "print(\"\\t                              dir is /data/db/<port>/ if not specified as the 2nd arg\");\n"
 "print(\"\\t                              returns a connection to the new server\");\n"
 "return;}\n"
 "print(\"\\t\" + \"db.help()                    help on db methods\");\n"
 "print(\"\\t\" + \"db.mycoll.help()             help on collection methods\");\n"
 "print(\"\\t\" + \"rs.help()                    help on replica set methods\");\n"
 "print(\"\\t\" + \"help connect                 connecting to a db help\");\n"
 "print(\"\\t\" + \"help admin                   administrative help\");\n"
 "print(\"\\t\" + \"help misc                    misc things to know\");\n"
 "print();\n"
 "print(\"\\t\" + \"show dbs                     show database names\");\n"
 "print(\"\\t\" + \"show collections             show collections in current database\");\n"
 "print(\"\\t\" + \"show users                   show users in current database\");\n"
 "print(\"\\t\" + \"show profile                 show most recent system.profile entries with time >= 1ms\");\n"
 "print(\"\\t\" + \"use <db_name>                set current database\");\n"
 "print(\"\\t\" + \"db.foo.find()                list objects in collection foo\");\n"
 "print(\"\\t\" + \"db.foo.find( { a : 1 } )     list objects in foo where a == 1\");\n"
 "print(\"\\t\" + \"it                           result of the last line evaluated; use to further iterate\");\n"
 "print(\"\\t\" + \"exit                         quit the mongo shell\");}\n"
 "if ( typeof DB == \"undefined\" ){\n"
 "DB = function( mongo , name ){\n"
 "this._mongo = mongo;\n"
 "this._name = name;}}\n"
 "DB.prototype.getMongo = function(){\n"
 "assert( this._mongo , \"why no mongo!\" );\n"
 "return this._mongo;}\n"
 "DB.prototype.getSisterDB = function( name ){\n"
 "return this.getMongo().getDB( name );}\n"
 "DB.prototype.getName = function(){\n"
 "return this._name;}\n"
 "DB.prototype.stats = function(){\n"
 "return this.runCommand( { dbstats : 1 } );}\n"
 "DB.prototype.getCollection = function( name ){\n"
 "return new DBCollection( this._mongo , this , name , this._name + \".\" + name );}\n"
 "DB.prototype.commandHelp = function( name ){\n"
 "var c = {};\n"
 "c[name] = 1;\n"
 "c.help = true;\n"
 "return this.runCommand( c ).help;}\n"
 "DB.prototype.runCommand = function( obj ){\n"
 "if ( typeof( obj ) == \"string\" ){\n"
 "var n = {};\n"
 "n[obj] = 1;\n"
 "obj = n;}\n"
 "return this.getCollection( \"$cmd\" ).findOne( obj );}\n"
 "DB.prototype._dbCommand = DB.prototype.runCommand;\n"
 "DB.prototype._adminCommand = function( obj ){\n"
 "if ( this._name == \"admin\" )\n"
 "return this.runCommand( obj );\n"
 "return this.getSisterDB( \"admin\" ).runCommand( obj );}\n"
 "DB.prototype.addUser = function( username , pass, readOnly ){\n"
 "readOnly = readOnly || false;\n"
 "var c = this.getCollection( \"system.users\" );\n"
 "var u = c.findOne( { user : username } ) || { user : username };\n"
 "u.readOnly = readOnly;\n"
 "u.pwd = hex_md5( username + \":mongo:\" + pass );\n"
 "print( tojson( u ) );\n"
 "c.save( u );}\n"
 "DB.prototype.removeUser = function( username ){\n"
 "this.getCollection( \"system.users\" ).remove( { user : username } );}\n"
 "DB.prototype.__pwHash = function( nonce, username, pass ) {\n"
 "return hex_md5( nonce + username + hex_md5( username + \":mongo:\" + pass ) );}\n"
 "DB.prototype.auth = function( username , pass ){\n"
 "var n = this.runCommand( { getnonce : 1 } );\n"
 "var a = this.runCommand(\n"
 "{\n"
 "authenticate : 1 ,\n"
 "user : username ,\n"
 "nonce : n.nonce ,\n"
 "key : this.__pwHash( n.nonce, username, pass )}\n"
 ");\n"
 "return a.ok;}\n"
 "\n"
 "DB.prototype.createCollection = function(name, opt) {\n"
 "var options = opt || {};\n"
 "var cmd = { create: name, capped: options.capped, size: options.size, max: options.max };\n"
 "var res = this._dbCommand(cmd);\n"
 "return res;}\n"
 "\n"
 "DB.prototype.getProfilingLevel  = function() {\n"
 "var res = this._dbCommand( { profile: -1 } );\n"
 "return res ? res.was : null;}\n"
 "\n"
 "DB.prototype.dropDatabase = function() {\n"
 "if ( arguments.length )\n"
 "throw \"dropDatabase doesn't take arguments\";\n"
 "return this._dbCommand( { dropDatabase: 1 } );}\n"
 "DB.prototype.shutdownServer = function() {\n"
 "if( \"admin\" != this._name ){\n"
 "return \"shutdown command only works with the admin database; try 'use admin'\";}\n"
 "try {\n"
 "var res = this._dbCommand(\"shutdown\");\n"
 "if( res )\n"
 "throw \"shutdownServer failed: \" + res.errmsg;\n"
 "throw \"shutdownServer failed\";}\n"
 "catch ( e ){\n"
 "assert( tojson( e ).indexOf( \"error doing query: failed\" ) >= 0 , \"unexpected error: \" + tojson( e ) );\n"
 "print( \"server should be down...\" );}}\n"
 "\n"
 "DB.prototype.cloneDatabase = function(from) {\n"
 "assert( isString(from) && from.length );\n"
 "return this._dbCommand( { clone: from } );}\n"
 "\n"
 "DB.prototype.cloneCollection = function(from, collection, query) {\n"
 "assert( isString(from) && from.length );\n"
 "assert( isString(collection) && collection.length );\n"
 "collection = this._name + \".\" + collection;\n"
 "query = query || {};\n"
 "return this._dbCommand( { cloneCollection:collection, from:from, query:query } );}\n"
 "\n"
 "DB.prototype.copyDatabase = function(fromdb, todb, fromhost, username, password) {\n"
 "assert( isString(fromdb) && fromdb.length );\n"
 "assert( isString(todb) && todb.length );\n"
 "fromhost = fromhost || \"\";\n"
 "if ( username && password ) {\n"
 "var n = this._adminCommand( { copydbgetnonce : 1, fromhost:fromhost } );\n"
 "return this._adminCommand( { copydb:1, fromhost:fromhost, fromdb:fromdb, todb:todb, username:username, nonce:n.nonce, key:this.__pwHash( n.nonce, username, password ) } );\n"
 "} else {\n"
 "return this._adminCommand( { copydb:1, fromhost:fromhost, fromdb:fromdb, todb:todb } );}}\n"
 "\n"
 "DB.prototype.repairDatabase = function() {\n"
 "return this._dbCommand( { repairDatabase: 1 } );}\n"
 "DB.prototype.help = function() {\n"
 "print(\"DB methods:\");\n"
 "print(\"\\tdb.addUser(username, password[, readOnly=false])\");\n"
 "print(\"\\tdb.auth(username, password)\");\n"
 "print(\"\\tdb.cloneDatabase(fromhost)\");\n"
 "print(\"\\tdb.commandHelp(name) returns the help for the command\");\n"
 "print(\"\\tdb.copyDatabase(fromdb, todb, fromhost)\");\n"
 "print(\"\\tdb.createCollection(name, { size : ..., capped : ..., max : ... } )\");\n"
 "print(\"\\tdb.currentOp() displays the current operation in the db\");\n"
 "print(\"\\tdb.dropDatabase()\");\n"
 "print(\"\\tdb.eval(func, args) run code server-side\");\n"
 "print(\"\\tdb.getCollection(cname) same as db['cname'] or db.cname\");\n"
 "print(\"\\tdb.getCollectionNames()\");\n"
 "print(\"\\tdb.getLastError() - just returns the err msg string\");\n"
 "print(\"\\tdb.getLastErrorObj() - return full status object\");\n"
 "print(\"\\tdb.getMongo() get the server connection object\");\n"
 "print(\"\\tdb.getMongo().setSlaveOk() allow this connection to read from the nonmaster member of a replica pair\");\n"
 "print(\"\\tdb.getName()\");\n"
 "print(\"\\tdb.getPrevError()\");\n"
 "print(\"\\tdb.getProfilingLevel()\");\n"
 "print(\"\\tdb.getReplicationInfo()\");\n"
 "print(\"\\tdb.getSisterDB(name) get the db at the same server as this one\");\n"
 "print(\"\\tdb.isMaster() check replica primary status\");\n"
 "print(\"\\tdb.killOp(opid) kills the current operation in the db\");\n"
 "print(\"\\tdb.listCommands() lists all the db commands\");\n"
 "print(\"\\tdb.printCollectionStats()\");\n"
 "print(\"\\tdb.printReplicationInfo()\");\n"
 "print(\"\\tdb.printSlaveReplicationInfo()\");\n"
 "print(\"\\tdb.printShardingStatus()\");\n"
 "print(\"\\tdb.removeUser(username)\");\n"
 "print(\"\\tdb.repairDatabase()\");\n"
 "print(\"\\tdb.resetError()\");\n"
 "print(\"\\tdb.runCommand(cmdObj) run a database command.  if cmdObj is a string, turns it into { cmdObj : 1 }\");\n"
 "print(\"\\tdb.serverStatus()\");\n"
 "print(\"\\tdb.setProfilingLevel(level,<slowms>) 0=off 1=slow 2=all\");\n"
 "print(\"\\tdb.shutdownServer()\");\n"
 "print(\"\\tdb.stats()\");\n"
 "print(\"\\tdb.version() current version of the server\");\n"
 "print(\"\\tdb.getMongo().setSlaveOk() allow queries on a replication slave server\");\n"
 "return __magicNoPrint;}\n"
 "DB.prototype.printCollectionStats = function(){\n"
 "var mydb = this;\n"
 "this.getCollectionNames().forEach(\n"
 "function(z){\n"
 "print( z );\n"
 "printjson( mydb.getCollection(z).stats() );\n"
 "print( \"---\" );}\n"
 ");}\n"
 "\n"
 "DB.prototype.setProfilingLevel = function(level,slowms) {\n"
 "if (level < 0 || level > 2) {\n"
 "throw { dbSetProfilingException : \"input level \" + level + \" is out of range [0..2]\" };}\n"
 "var cmd = { profile: level };\n"
 "if ( slowms )\n"
 "cmd[\"slowms\"] = slowms;\n"
 "return this._dbCommand( cmd );}\n"
 "\n"
 "DB.prototype.eval = function(jsfunction) {\n"
 "var cmd = { $eval : jsfunction };\n"
 "if ( arguments.length > 1 ) {\n"
 "cmd.args = argumentsToArray( arguments ).slice(1);}\n"
 "var res = this._dbCommand( cmd );\n"
 "if (!res.ok)\n"
 "throw tojson( res );\n"
 "return res.retval;}\n"
 "DB.prototype.dbEval = DB.prototype.eval;\n"
 "\n"
 "DB.prototype.groupeval = function(parmsObj) {\n"
 "var groupFunction = function() {\n"
 "var parms = args[0];\n"
 "var c = db[parms.ns].find(parms.cond||{});\n"
 "var map = new Map();\n"
 "var pks = parms.key ? Object.keySet( parms.key ) : null;\n"
 "var pkl = pks ? pks.length : 0;\n"
 "var key = {};\n"
 "while( c.hasNext() ) {\n"
 "var obj = c.next();\n"
 "if ( pks ) {\n"
 "for( var i=0; i<pkl; i++ ){\n"
 "var k = pks[i];\n"
 "key[k] = obj[k];}}\n"
 "else {\n"
 "key = parms.$keyf(obj);}\n"
 "var aggObj = map.get(key);\n"
 "if( aggObj == null ) {\n"
 "var newObj = Object.extend({}, key);\n"
 "aggObj = Object.extend(newObj, parms.initial)\n"
 "map.put( key , aggObj );}\n"
 "parms.$reduce(obj, aggObj);}\n"
 "return map.values();}\n"
 "return this.eval(groupFunction, this._groupFixParms( parmsObj ));}\n"
 "DB.prototype.groupcmd = function( parmsObj ){\n"
 "var ret = this.runCommand( { \"group\" : this._groupFixParms( parmsObj ) } );\n"
 "if ( ! ret.ok ){\n"
 "throw \"group command failed: \" + tojson( ret );}\n"
 "return ret.retval;}\n"
 "DB.prototype.group = DB.prototype.groupcmd;\n"
 "DB.prototype._groupFixParms = function( parmsObj ){\n"
 "var parms = Object.extend({}, parmsObj);\n"
 "if( parms.reduce ) {\n"
 "parms.$reduce = parms.reduce;\n"
 "delete parms.reduce;}\n"
 "if( parms.keyf ) {\n"
 "parms.$keyf = parms.keyf;\n"
 "delete parms.keyf;}\n"
 "return parms;}\n"
 "DB.prototype.resetError = function(){\n"
 "return this.runCommand( { reseterror : 1 } );}\n"
 "DB.prototype.forceError = function(){\n"
 "return this.runCommand( { forceerror : 1 } );}\n"
 "DB.prototype.getLastError = function( w , wtimeout ){\n"
 "var res = this.getLastErrorObj( w , wtimeout );\n"
 "if ( ! res.ok )\n"
 "throw \"getlasterror failed: \" + tojson( res );\n"
 "return res.err;}\n"
 "DB.prototype.getLastErrorObj = function( w , wtimeout ){\n"
 "var cmd = { getlasterror : 1 };\n"
 "if ( w ){\n"
 "cmd.w = w;\n"
 "if ( wtimeout )\n"
 "cmd.wtimeout = wtimeout;}\n"
 "var res = this.runCommand( cmd );\n"
 "if ( ! res.ok )\n"
 "throw \"getlasterror failed: \" + tojson( res );\n"
 "return res;}\n"
 "DB.prototype.getLastErrorCmd = DB.prototype.getLastErrorObj;\n"
 "/* Return the last error which has occurred, even if not the very last error.\n"
 "Returns:\n"
 "{ err : <error message>, nPrev : <how_many_ops_back_occurred>, ok : 1 }\n"
 "result.err will be null if no error has occurred.\n"
 "*/\n"
 "DB.prototype.getPrevError = function(){\n"
 "return this.runCommand( { getpreverror : 1 } );}\n"
 "DB.prototype.getCollectionNames = function(){\n"
 "var all = [];\n"
 "var nsLength = this._name.length + 1;\n"
 "var c = this.getCollection( \"system.namespaces\" ).find();\n"
 "while ( c.hasNext() ){\n"
 "var name = c.next().name;\n"
 "if ( name.indexOf( \"$\" ) >= 0 && name.indexOf( \".oplog.$\" ) < 0 )\n"
 "continue;\n"
 "all.push( name.substring( nsLength ) );}\n"
 "return all.sort();}\n"
 "DB.prototype.tojson = function(){\n"
 "return this._name;}\n"
 "DB.prototype.toString = function(){\n"
 "return this._name;}\n"
 "DB.prototype.isMaster = function () { return this.runCommand(\"isMaster\"); }\n"
 "DB.prototype.currentOp = function(){\n"
 "return db.$cmd.sys.inprog.findOne();}\n"
 "DB.prototype.currentOP = DB.prototype.currentOp;\n"
 "DB.prototype.killOp = function(op) {\n"
 "if( !op )\n"
 "throw \"no opNum to kill specified\";\n"
 "return db.$cmd.sys.killop.findOne({'op':op});}\n"
 "DB.prototype.killOP = DB.prototype.killOp;\n"
 "DB.tsToSeconds = function(x){\n"
 "if ( x.t && x.i )\n"
 "return x.t / 1000;\n"
 "return x / 4294967296;}\n"
 "\n"
 "DB.prototype.getReplicationInfo = function() {\n"
 "var db = this.getSisterDB(\"local\");\n"
 "var result = { };\n"
 "var ol = db.system.namespaces.findOne({name:\"local.oplog.$main\"});\n"
 "if( ol && ol.options ) {\n"
 "result.logSizeMB = ol.options.size / 1000 / 1000;\n"
 "} else {\n"
 "result.errmsg  = \"local.oplog.$main, or its options, not found in system.namespaces collection (not --master?)\";\n"
 "return result;}\n"
 "var firstc = db.oplog.$main.find().sort({$natural:1}).limit(1);\n"
 "var lastc = db.oplog.$main.find().sort({$natural:-1}).limit(1);\n"
 "if( !firstc.hasNext() || !lastc.hasNext() ) {\n"
 "result.errmsg = \"objects not found in local.oplog.$main -- is this a new and empty db instance?\";\n"
 "result.oplogMainRowCount = db.oplog.$main.count();\n"
 "return result;}\n"
 "var first = firstc.next();\n"
 "var last = lastc.next();\n"
 "{\n"
 "var tfirst = first.ts;\n"
 "var tlast = last.ts;\n"
 "if( tfirst && tlast ) {\n"
 "tfirst = DB.tsToSeconds( tfirst );\n"
 "tlast = DB.tsToSeconds( tlast );\n"
 "result.timeDiff = tlast - tfirst;\n"
 "result.timeDiffHours = Math.round(result.timeDiff / 36)/100;\n"
 "result.tFirst = (new Date(tfirst*1000)).toString();\n"
 "result.tLast  = (new Date(tlast*1000)).toString();\n"
 "result.now = Date();}\n"
 "else {\n"
 "result.errmsg = \"ts element not found in oplog objects\";}}\n"
 "return result;}\n"
 "DB.prototype.printReplicationInfo = function() {\n"
 "var result = this.getReplicationInfo();\n"
 "if( result.errmsg ) {\n"
 "print(tojson(result));\n"
 "return;}\n"
 "print(\"configured oplog size:   \" + result.logSizeMB + \"MB\");\n"
 "print(\"log length start to end: \" + result.timeDiff + \"secs (\" + result.timeDiffHours + \"hrs)\");\n"
 "print(\"oplog first event time:  \" + result.tFirst);\n"
 "print(\"oplog last event time:   \" + result.tLast);\n"
 "print(\"now:                     \" + result.now);}\n"
 "DB.prototype.printSlaveReplicationInfo = function() {\n"
 "function g(x) {\n"
 "assert( x , \"how could this be null (printSlaveReplicationInfo gx)\" )\n"
 "print(\"source:   \" + x.host);\n"
 "if ( x.syncedTo ){\n"
 "var st = new Date( DB.tsToSeconds( x.syncedTo ) * 1000 );\n"
 "var now = new Date();\n"
 "print(\"\\t syncedTo: \" + st.toString() );\n"
 "var ago = (now-st)/1000;\n"
 "var hrs = Math.round(ago/36)/100;\n"
 "print(\"\\t\\t = \" + Math.round(ago) + \"secs ago (\" + hrs + \"hrs)\");}\n"
 "else {\n"
 "print( \"\\t doing initial sync\" );}}\n"
 "var L = this.getSisterDB(\"local\");\n"
 "if( L.sources.count() == 0 ) {\n"
 "print(\"local.sources is empty; is this db a --slave?\");\n"
 "return;}\n"
 "L.sources.find().forEach(g);}\n"
 "DB.prototype.serverBuildInfo = function(){\n"
 "return this._adminCommand( \"buildinfo\" );}\n"
 "DB.prototype.serverStatus = function(){\n"
 "return this._adminCommand( \"serverStatus\" );}\n"
 "DB.prototype.serverCmdLineOpts = function(){\n"
 "return this._adminCommand( \"getCmdLineOpts\" );}\n"
 "DB.prototype.version = function(){\n"
 "return this.serverBuildInfo().version;}\n"
 "DB.prototype.listCommands = function(){\n"
 "var x = this.runCommand( \"listCommands\" );\n"
 "for ( var name in x.commands ){\n"
 "var c = x.commands[name];\n"
 "var s = name + \": \";\n"
 "switch ( c.lockType ){\n"
 "case -1: s += \"read-lock\"; break;\n"
 "case  0: s += \"no-lock\"; break;\n"
 "case  1: s += \"write-lock\"; break;\n"
 "default: s += c.lockType;}\n"
 "if (c.adminOnly) s += \" adminOnly \";\n"
 "if (c.adminOnly) s += \" slaveOk \";\n"
 "s += \"\\n  \";\n"
 "s += c.help.replace(/\\n/g, '\\n  ');\n"
 "s += \"\\n\";\n"
 "print( s );}}\n"
 "DB.prototype.printShardingStatus = function(){\n"
 "printShardingStatus( this.getSisterDB( \"config\" ) );}\n"
 "if ( typeof Mongo == \"undefined\" ){\n"
 "Mongo = function( host ){\n"
 "this.init( host );}}\n"
 "if ( ! Mongo.prototype ){\n"
 "throw \"Mongo.prototype not defined\";}\n"
 "if ( ! Mongo.prototype.find )\n"
 "Mongo.prototype.find = function( ns , query , fields , limit , skip ){ throw \"find not implemented\"; }\n"
 "if ( ! Mongo.prototype.insert )\n"
 "Mongo.prototype.insert = function( ns , obj ){ throw \"insert not implemented\"; }\n"
 "if ( ! Mongo.prototype.remove )\n"
 "Mongo.prototype.remove = function( ns , pattern ){ throw \"remove not implemented;\" }\n"
 "if ( ! Mongo.prototype.update )\n"
 "Mongo.prototype.update = function( ns , query , obj , upsert ){ throw \"update not implemented;\" }\n"
 "if ( typeof mongoInject == \"function\" ){\n"
 "mongoInject( Mongo.prototype );}\n"
 "Mongo.prototype.setSlaveOk = function() {\n"
 "this.slaveOk = true;}\n"
 "Mongo.prototype.getDB = function( name ){\n"
 "return new DB( this , name );}\n"
 "Mongo.prototype.getDBs = function(){\n"
 "var res = this.getDB( \"admin\" ).runCommand( { \"listDatabases\" : 1 } );\n"
 "assert( res.ok == 1 , \"listDatabases failed:\" + tojson( res ) );\n"
 "return res;}\n"
 "Mongo.prototype.getDBNames = function(){\n"
 "return this.getDBs().databases.map(\n"
 "function(z){\n"
 "return z.name;}\n"
 ");}\n"
 "Mongo.prototype.getCollection = function(ns){\n"
 "var idx = ns.indexOf( \".\" );\n"
 "if ( idx < 0 )\n"
 "throw \"need . in ns\";\n"
 "var db = ns.substring( 0 , idx );\n"
 "var c = ns.substring( idx + 1 );\n"
 "return this.getDB( db ).getCollection( c );}\n"
 "Mongo.prototype.toString = function(){\n"
 "return \"connection to \" + this.host;}\n"
 "Mongo.prototype.tojson = Mongo.prototype.toString;\n"
 "connect = function( url , user , pass ){\n"
 "chatty( \"connecting to: \" + url )\n"
 "if ( user && ! pass )\n"
 "throw \"you specified a user and not a password.  either you need a password, or you're using the old connect api\";\n"
 "var idx = url.lastIndexOf( \"/\" );\n"
 "var db;\n"
 "if ( idx < 0 )\n"
 "db = new Mongo().getDB( url );\n"
 "else\n"
 "db = new Mongo( url.substring( 0 , idx ) ).getDB( url.substring( idx + 1 ) );\n"
 "if ( user && pass ){\n"
 "if ( ! db.auth( user , pass ) ){\n"
 "throw \"couldn't login\";}}\n"
 "return db;}\n"
 "MR = {};\n"
 "MR.init = function(){\n"
 "$max = 0;\n"
 "$arr = [];\n"
 "emit = MR.emit;\n"
 "$numEmits = 0;\n"
 "$numReduces = 0;\n"
 "$numReducesToDB = 0;\n"
 "gc();}\n"
 "MR.cleanup = function(){\n"
 "MR.init();\n"
 "gc();}\n"
 "MR.emit = function(k,v){\n"
 "$numEmits++;\n"
 "var num = nativeHelper.apply( get_num_ , [ k ] );\n"
 "var data = $arr[num];\n"
 "if ( ! data ){\n"
 "data = { key : k , values : new Array(1000) , count : 0 };\n"
 "$arr[num] = data;}\n"
 "data.values[data.count++] = v;\n"
 "$max = Math.max( $max , data.count );}\n"
 "MR.doReduce = function( useDB ){\n"
 "$numReduces++;\n"
 "if ( useDB )\n"
 "$numReducesToDB++;\n"
 "$max = 0;\n"
 "for ( var i=0; i<$arr.length; i++){\n"
 "var data = $arr[i];\n"
 "if ( ! data )\n"
 "continue;\n"
 "if ( useDB ){\n"
 "var x = tempcoll.findOne( { _id : data.key } );\n"
 "if ( x ){\n"
 "data.values[data.count++] = x.value;}}\n"
 "var r = $reduce( data.key , data.values.slice( 0 , data.count ) );\n"
 "if ( r && r.length && r[0] ){\n"
 "data.values = r;\n"
 "data.count = r.length;}\n"
 "else{\n"
 "data.values[0] = r;\n"
 "data.count = 1;}\n"
 "$max = Math.max( $max , data.count );\n"
 "if ( useDB ){\n"
 "if ( data.count == 1 ){\n"
 "tempcoll.save( { _id : data.key , value : data.values[0] } );}\n"
 "else {\n"
 "tempcoll.save( { _id : data.key , value : data.values.slice( 0 , data.count ) } );}}}}\n"
 "MR.check = function(){\n"
 "if ( $max < 2000 && $arr.length < 1000 ){\n"
 "return 0;}\n"
 "MR.doReduce();\n"
 "if ( $max < 2000 && $arr.length < 1000 ){\n"
 "return 1;}\n"
 "MR.doReduce( true );\n"
 "$arr = [];\n"
 "$max = 0;\n"
 "reset_num();\n"
 "gc();\n"
 "return 2;}\n"
 "MR.finalize = function(){\n"
 "tempcoll.find().forEach(\n"
 "function(z){\n"
 "z.value = $finalize( z._id , z.value );\n"
 "tempcoll.save( z );}\n"
 ");}\n"
 "if ( typeof DBQuery == \"undefined\" ){\n"
 "DBQuery = function( mongo , db , collection , ns , query , fields , limit , skip , batchSize ){\n"
 "this._mongo = mongo;\n"
 "this._db = db;\n"
 "this._collection = collection;\n"
 "this._ns = ns;\n"
 "this._query = query || {};\n"
 "this._fields = fields;\n"
 "this._limit = limit || 0;\n"
 "this._skip = skip || 0;\n"
 "this._batchSize = batchSize || 0;\n"
 "this._cursor = null;\n"
 "this._numReturned = 0;\n"
 "this._special = false;\n"
 "this._prettyShell = false;}\n"
 "print( \"DBQuery probably won't have array access \" );}\n"
 "DBQuery.prototype.help = function () {\n"
 "print(\"find() modifiers\")\n"
 "print(\"\\t.sort( {...} )\")\n"
 "print(\"\\t.limit( n )\")\n"
 "print(\"\\t.skip( n )\")\n"
 "print(\"\\t.count() - total # of objects matching query, ignores skip,limit\")\n"
 "print(\"\\t.size() - total # of objects cursor would return, honors skip,limit\")\n"
 "print(\"\\t.explain([verbose])\")\n"
 "print(\"\\t.hint(...)\")\n"
 "print(\"\\t.showDiskLoc() - adds a $diskLoc field to each returned object\")\n"
 "print(\"\\nCursor methods\");\n"
 "print(\"\\t.forEach( func )\")\n"
 "print(\"\\t.print() - output to console in full pretty format\")\n"
 "print(\"\\t.map( func )\")\n"
 "print(\"\\t.hasNext()\")\n"
 "print(\"\\t.next()\")}\n"
 "DBQuery.prototype.clone = function(){\n"
 "var q =  new DBQuery( this._mongo , this._db , this._collection , this._ns ,\n"
 "this._query , this._fields ,\n"
 "this._limit , this._skip , this._batchSize );\n"
 "q._special = this._special;\n"
 "return q;}\n"
 "DBQuery.prototype._ensureSpecial = function(){\n"
 "if ( this._special )\n"
 "return;\n"
 "var n = { query : this._query };\n"
 "this._query = n;\n"
 "this._special = true;}\n"
 "DBQuery.prototype._checkModify = function(){\n"
 "if ( this._cursor )\n"
 "throw \"query already executed\";}\n"
 "DBQuery.prototype._exec = function(){\n"
 "if ( ! this._cursor ){\n"
 "assert.eq( 0 , this._numReturned );\n"
 "this._cursor = this._mongo.find( this._ns , this._query , this._fields , this._limit , this._skip , this._batchSize );\n"
 "this._cursorSeen = 0;}\n"
 "return this._cursor;}\n"
 "DBQuery.prototype.limit = function( limit ){\n"
 "this._checkModify();\n"
 "this._limit = limit;\n"
 "return this;}\n"
 "DBQuery.prototype.batchSize = function( batchSize ){\n"
 "this._checkModify();\n"
 "this._batchSize = batchSize;\n"
 "return this;}\n"
 "DBQuery.prototype.skip = function( skip ){\n"
 "this._checkModify();\n"
 "this._skip = skip;\n"
 "return this;}\n"
 "DBQuery.prototype.hasNext = function(){\n"
 "this._exec();\n"
 "if ( this._limit > 0 && this._cursorSeen >= this._limit )\n"
 "return false;\n"
 "var o = this._cursor.hasNext();\n"
 "return o;}\n"
 "DBQuery.prototype.next = function(){\n"
 "this._exec();\n"
 "var o = this._cursor.hasNext();\n"
 "if ( o )\n"
 "this._cursorSeen++;\n"
 "else\n"
 "throw \"error hasNext: \" + o;\n"
 "var ret = this._cursor.next();\n"
 "if ( ret.$err && this._numReturned == 0 && ! this.hasNext() )\n"
 "throw \"error: \" + tojson( ret );\n"
 "this._numReturned++;\n"
 "return ret;}\n"
 "DBQuery.prototype.objsLeftInBatch = function(){\n"
 "this._exec();\n"
 "var ret = this._cursor.objsLeftInBatch();\n"
 "if ( ret.$err )\n"
 "throw \"error: \" + tojson( ret );\n"
 "return ret;}\n"
 "DBQuery.prototype.toArray = function(){\n"
 "if ( this._arr )\n"
 "return this._arr;\n"
 "var a = [];\n"
 "while ( this.hasNext() )\n"
 "a.push( this.next() );\n"
 "this._arr = a;\n"
 "return a;}\n"
 "DBQuery.prototype.count = function( applySkipLimit ){\n"
 "var cmd = { count: this._collection.getName() };\n"
 "if ( this._query ){\n"
 "if ( this._special )\n"
 "cmd.query = this._query.query;\n"
 "else\n"
 "cmd.query = this._query;}\n"
 "cmd.fields = this._fields || {};\n"
 "if ( applySkipLimit ){\n"
 "if ( this._limit )\n"
 "cmd.limit = this._limit;\n"
 "if ( this._skip )\n"
 "cmd.skip = this._skip;}\n"
 "var res = this._db.runCommand( cmd );\n"
 "if( res && res.n != null ) return res.n;\n"
 "throw \"count failed: \" + tojson( res );}\n"
 "DBQuery.prototype.size = function(){\n"
 "return this.count( true );}\n"
 "DBQuery.prototype.countReturn = function(){\n"
 "var c = this.count();\n"
 "if ( this._skip )\n"
 "c = c - this._skip;\n"
 "if ( this._limit > 0 && this._limit < c )\n"
 "return this._limit;\n"
 "return c;}\n"
 "\n"
 "DBQuery.prototype.itcount = function(){\n"
 "var num = 0;\n"
 "while ( this.hasNext() ){\n"
 "num++;\n"
 "this.next();}\n"
 "return num;}\n"
 "DBQuery.prototype.length = function(){\n"
 "return this.toArray().length;}\n"
 "DBQuery.prototype._addSpecial = function( name , value ){\n"
 "this._ensureSpecial();\n"
 "this._query[name] = value;\n"
 "return this;}\n"
 "DBQuery.prototype.sort = function( sortBy ){\n"
 "return this._addSpecial( \"orderby\" , sortBy );}\n"
 "DBQuery.prototype.hint = function( hint ){\n"
 "return this._addSpecial( \"$hint\" , hint );}\n"
 "DBQuery.prototype.min = function( min ) {\n"
 "return this._addSpecial( \"$min\" , min );}\n"
 "DBQuery.prototype.max = function( max ) {\n"
 "return this._addSpecial( \"$max\" , max );}\n"
 "DBQuery.prototype.showDiskLoc = function() {\n"
 "return this._addSpecial( \"$showDiskLoc\" , true);}\n"
 "DBQuery.prototype.forEach = function( func ){\n"
 "while ( this.hasNext() )\n"
 "func( this.next() );}\n"
 "DBQuery.prototype.map = function( func ){\n"
 "var a = [];\n"
 "while ( this.hasNext() )\n"
 "a.push( func( this.next() ) );\n"
 "return a;}\n"
 "DBQuery.prototype.arrayAccess = function( idx ){\n"
 "return this.toArray()[idx];}\n"
 "DBQuery.prototype.explain = function (verbose) {\n"
 "/* verbose=true --> include allPlans, oldPlan fields */\n"
 "var n = this.clone();\n"
 "n._ensureSpecial();\n"
 "n._query.$explain = true;\n"
 "n._limit = n._limit * -1;\n"
 "var e = n.next();\n"
 "if (!verbose) {\n"
 "delete e.allPlans;\n"
 "delete e.oldPlan;}\n"
 "return e;}\n"
 "DBQuery.prototype.snapshot = function(){\n"
 "this._ensureSpecial();\n"
 "this._query.$snapshot = true;\n"
 "return this;}\n"
 "DBQuery.prototype.pretty = function(){\n"
 "this._prettyShell = true;\n"
 "return this;}\n"
 "DBQuery.prototype.shellPrint = function(){\n"
 "try {\n"
 "var n = 0;\n"
 "while ( this.hasNext() && n < DBQuery.shellBatchSize ){\n"
 "var s = this._prettyShell ? tojson( this.next() ) : tojson( this.next() , \"\" , true );\n"
 "print( s );\n"
 "n++;}\n"
 "if ( this.hasNext() ){\n"
 "print( \"has more\" );\n"
 "___it___  = this;}\n"
 "else {\n"
 "___it___  = null;}}\n"
 "catch ( e ){\n"
 "print( e );}}\n"
 "DBQuery.prototype.toString = function(){\n"
 "return \"DBQuery: \" + this._ns + \" -> \" + tojson( this.query );}\n"
 "DBQuery.shellBatchSize = 20;\n"
 "// or db[\"colName\"]\n"
 "if ( ( typeof  DBCollection ) == \"undefined\" ){\n"
 "DBCollection = function( mongo , db , shortName , fullName ){\n"
 "this._mongo = mongo;\n"
 "this._db = db;\n"
 "this._shortName = shortName;\n"
 "this._fullName = fullName;\n"
 "this.verify();}}\n"
 "DBCollection.prototype.verify = function(){\n"
 "assert( this._fullName , \"no fullName\" );\n"
 "assert( this._shortName , \"no shortName\" );\n"
 "assert( this._db , \"no db\" );\n"
 "assert.eq( this._fullName , this._db._name + \".\" + this._shortName , \"name mismatch\" );\n"
 "assert( this._mongo , \"no mongo in DBCollection\" );}\n"
 "DBCollection.prototype.getName = function(){\n"
 "return this._shortName;}\n"
 "DBCollection.prototype.help = function () {\n"
 "var shortName = this.getName();\n"
 "print(\"DBCollection help\");\n"
 "print(\"\\tdb.\" + shortName + \".find().help() - show DBCursor help\");\n"
 "print(\"\\tdb.\" + shortName + \".count()\");\n"
 "print(\"\\tdb.\" + shortName + \".dataSize()\");\n"
 "print(\"\\tdb.\" + shortName + \".distinct( key ) - eg. db.\" + shortName + \".distinct( 'x' )\");\n"
 "print(\"\\tdb.\" + shortName + \".drop() drop the collection\");\n"
 "print(\"\\tdb.\" + shortName + \".dropIndex(name)\");\n"
 "print(\"\\tdb.\" + shortName + \".dropIndexes()\");\n"
 "print(\"\\tdb.\" + shortName + \".ensureIndex(keypattern,options) - options should be an object with these possible fields: name, unique, dropDups\");\n"
 "print(\"\\tdb.\" + shortName + \".reIndex()\");\n"
 "print(\"\\tdb.\" + shortName + \".find( [query] , [fields]) - first parameter is an optional query filter. second parameter is optional set of fields to return.\");\n"
 "print(\"\\t                                   e.g. db.\" + shortName + \".find( { x : 77 } , { name : 1 , x : 1 } )\");\n"
 "print(\"\\tdb.\" + shortName + \".find(...).count()\");\n"
 "print(\"\\tdb.\" + shortName + \".find(...).limit(n)\");\n"
 "print(\"\\tdb.\" + shortName + \".find(...).skip(n)\");\n"
 "print(\"\\tdb.\" + shortName + \".find(...).sort(...)\");\n"
 "print(\"\\tdb.\" + shortName + \".findOne([query])\");\n"
 "print(\"\\tdb.\" + shortName + \".findAndModify( { update : ... , remove : bool [, query: {}, sort: {}, 'new': false] } )\");\n"
 "print(\"\\tdb.\" + shortName + \".getDB() get DB object associated with collection\");\n"
 "print(\"\\tdb.\" + shortName + \".getIndexes()\");\n"
 "print(\"\\tdb.\" + shortName + \".group( { key : ..., initial: ..., reduce : ...[, cond: ...] } )\");\n"
 "print(\"\\tdb.\" + shortName + \".mapReduce( mapFunction , reduceFunction , <optional params> )\");\n"
 "print(\"\\tdb.\" + shortName + \".remove(query)\");\n"
 "print(\"\\tdb.\" + shortName + \".renameCollection( newName , <dropTarget> ) renames the collection.\");\n"
 "print(\"\\tdb.\" + shortName + \".runCommand( name , <options> ) runs a db command with the given name where the first param is the collection name\");\n"
 "print(\"\\tdb.\" + shortName + \".save(obj)\");\n"
 "print(\"\\tdb.\" + shortName + \".stats()\");\n"
 "print(\"\\tdb.\" + shortName + \".storageSize() - includes free space allocated to this collection\");\n"
 "print(\"\\tdb.\" + shortName + \".totalIndexSize() - size in bytes of all the indexes\");\n"
 "print(\"\\tdb.\" + shortName + \".totalSize() - storage allocated for all data and indexes\");\n"
 "print(\"\\tdb.\" + shortName + \".update(query, object[, upsert_bool, multi_bool])\");\n"
 "print(\"\\tdb.\" + shortName + \".validate() - SLOW\");\n"
 "print(\"\\tdb.\" + shortName + \".getShardVersion() - only for use with sharding\");\n"
 "return __magicNoPrint;}\n"
 "DBCollection.prototype.getFullName = function(){\n"
 "return this._fullName;}\n"
 "DBCollection.prototype.getDB = function(){\n"
 "return this._db;}\n"
 "DBCollection.prototype._dbCommand = function( cmd , params ){\n"
 "if ( typeof( cmd ) == \"object\" )\n"
 "return this._db._dbCommand( cmd );\n"
 "var c = {};\n"
 "c[cmd] = this.getName();\n"
 "if ( params )\n"
 "Object.extend( c , params );\n"
 "return this._db._dbCommand( c );}\n"
 "DBCollection.prototype.runCommand = DBCollection.prototype._dbCommand;\n"
 "DBCollection.prototype._massageObject = function( q ){\n"
 "if ( ! q )\n"
 "return {};\n"
 "var type = typeof q;\n"
 "if ( type == \"function\" )\n"
 "return { $where : q };\n"
 "if ( q.isObjectId )\n"
 "return { _id : q };\n"
 "if ( type == \"object\" )\n"
 "return q;\n"
 "if ( type == \"string\" ){\n"
 "if ( q.length == 24 )\n"
 "return { _id : q };\n"
 "return { $where : q };}\n"
 "throw \"don't know how to massage : \" + type;}\n"
 "DBCollection.prototype._validateObject = function( o ){\n"
 "if ( o._ensureSpecial && o._checkModify )\n"
 "throw \"can't save a DBQuery object\";}\n"
 "DBCollection._allowedFields = { $id : 1 , $ref : 1 };\n"
 "DBCollection.prototype._validateForStorage = function( o ){\n"
 "this._validateObject( o );\n"
 "for ( var k in o ){\n"
 "if ( k.indexOf( \".\" ) >= 0 ) {\n"
 "throw \"can't have . in field names [\" + k + \"]\" ;}\n"
 "if ( k.indexOf( \"$\" ) == 0 && ! DBCollection._allowedFields[k] ) {\n"
 "throw \"field names cannot start with $ [\" + k + \"]\";}\n"
 "if ( o[k] !== null && typeof( o[k] ) === \"object\" ) {\n"
 "this._validateForStorage( o[k] );}}\n"
 "};\n"
 "DBCollection.prototype.find = function( query , fields , limit , skip ){\n"
 "return new DBQuery( this._mongo , this._db , this ,\n"
 "this._fullName , this._massageObject( query ) , fields , limit , skip );}\n"
 "DBCollection.prototype.findOne = function( query , fields ){\n"
 "var cursor = this._mongo.find( this._fullName , this._massageObject( query ) || {} , fields , -1 , 0 , 0 );\n"
 "if ( ! cursor.hasNext() )\n"
 "return null;\n"
 "var ret = cursor.next();\n"
 "if ( cursor.hasNext() ) throw \"findOne has more than 1 result!\";\n"
 "if ( ret.$err )\n"
 "throw \"error \" + tojson( ret );\n"
 "return ret;}\n"
 "DBCollection.prototype.insert = function( obj , _allow_dot ){\n"
 "if ( ! obj )\n"
 "throw \"no object passed to insert!\";\n"
 "if ( ! _allow_dot ) {\n"
 "this._validateForStorage( obj );}\n"
 "if ( typeof( obj._id ) == \"undefined\" ){\n"
 "var tmp = obj;\n"
 "obj = {_id: new ObjectId()};\n"
 "for (var key in tmp){\n"
 "obj[key] = tmp[key];}}\n"
 "this._mongo.insert( this._fullName , obj );\n"
 "this._lastID = obj._id;}\n"
 "DBCollection.prototype.remove = function( t ){\n"
 "this._mongo.remove( this._fullName , this._massageObject( t ) );}\n"
 "DBCollection.prototype.update = function( query , obj , upsert , multi ){\n"
 "assert( query , \"need a query\" );\n"
 "assert( obj , \"need an object\" );\n"
 "this._validateObject( obj );\n"
 "this._mongo.update( this._fullName , query , obj , upsert ? true : false , multi ? true : false );}\n"
 "DBCollection.prototype.save = function( obj ){\n"
 "if ( obj == null || typeof( obj ) == \"undefined\" )\n"
 "throw \"can't save a null\";\n"
 "if ( typeof( obj._id ) == \"undefined\" ){\n"
 "obj._id = new ObjectId();\n"
 "return this.insert( obj );}\n"
 "else {\n"
 "return this.update( { _id : obj._id } , obj , true );}}\n"
 "DBCollection.prototype._genIndexName = function( keys ){\n"
 "var name = \"\";\n"
 "for ( var k in keys ){\n"
 "var v = keys[k];\n"
 "if ( typeof v == \"function\" )\n"
 "continue;\n"
 "if ( name.length > 0 )\n"
 "name += \"_\";\n"
 "name += k + \"_\";\n"
 "if ( typeof v == \"number\" )\n"
 "name += v;}\n"
 "return name;}\n"
 "DBCollection.prototype._indexSpec = function( keys, options ) {\n"
 "var ret = { ns : this._fullName , key : keys , name : this._genIndexName( keys ) };\n"
 "if ( ! options ){}\n"
 "else if ( typeof ( options ) == \"string\" )\n"
 "ret.name = options;\n"
 "else if ( typeof ( options ) == \"boolean\" )\n"
 "ret.unique = true;\n"
 "else if ( typeof ( options ) == \"object\" ){\n"
 "if ( options.length ){\n"
 "var nb = 0;\n"
 "for ( var i=0; i<options.length; i++ ){\n"
 "if ( typeof ( options[i] ) == \"string\" )\n"
 "ret.name = options[i];\n"
 "else if ( typeof( options[i] ) == \"boolean\" ){\n"
 "if ( options[i] ){\n"
 "if ( nb == 0 )\n"
 "ret.unique = true;\n"
 "if ( nb == 1 )\n"
 "ret.dropDups = true;}\n"
 "nb++;}}}\n"
 "else {\n"
 "Object.extend( ret , options );}}\n"
 "else {\n"
 "throw \"can't handle: \" + typeof( options );}\n"
 "/*\n"
 "return ret;\n"
 "var name;\n"
 "var nTrue = 0;\n"
 "if ( ! isObject( options ) ) {\n"
 "options = [ options ];}\n"
 "if ( options.length ){\n"
 "for( var i = 0; i < options.length; ++i ) {\n"
 "var o = options[ i ];\n"
 "if ( isString( o ) ) {\n"
 "ret.name = o;\n"
 "} else if ( typeof( o ) == \"boolean\" ) {\n"
 "if ( o ) {\n"
 "++nTrue;}}}\n"
 "if ( nTrue > 0 ) {\n"
 "ret.unique = true;}\n"
 "if ( nTrue > 1 ) {\n"
 "ret.dropDups = true;}}\n"
 "*/\n"
 "return ret;}\n"
 "DBCollection.prototype.createIndex = function( keys , options ){\n"
 "var o = this._indexSpec( keys, options );\n"
 "this._db.getCollection( \"system.indexes\" ).insert( o , true );}\n"
 "DBCollection.prototype.ensureIndex = function( keys , options ){\n"
 "var name = this._indexSpec( keys, options ).name;\n"
 "this._indexCache = this._indexCache || {};\n"
 "if ( this._indexCache[ name ] ){\n"
 "return;}\n"
 "this.createIndex( keys , options );\n"
 "if ( this.getDB().getLastError() == \"\" ) {\n"
 "this._indexCache[name] = true;}}\n"
 "DBCollection.prototype.resetIndexCache = function(){\n"
 "this._indexCache = {};}\n"
 "DBCollection.prototype.reIndex = function() {\n"
 "return this._db.runCommand({ reIndex: this.getName() });}\n"
 "DBCollection.prototype.dropIndexes = function(){\n"
 "this.resetIndexCache();\n"
 "var res = this._db.runCommand( { deleteIndexes: this.getName(), index: \"*\" } );\n"
 "assert( res , \"no result from dropIndex result\" );\n"
 "if ( res.ok )\n"
 "return res;\n"
 "if ( res.errmsg.match( /not found/ ) )\n"
 "return res;\n"
 "throw \"error dropping indexes : \" + tojson( res );}\n"
 "DBCollection.prototype.drop = function(){\n"
 "this.resetIndexCache();\n"
 "var ret = this._db.runCommand( { drop: this.getName() } );\n"
 "if ( ! ret.ok ){\n"
 "if ( ret.errmsg == \"ns not found\" )\n"
 "return false;\n"
 "throw \"drop failed: \" + tojson( ret );}\n"
 "return true;}\n"
 "DBCollection.prototype.findAndModify = function(args){\n"
 "var cmd = { findandmodify: this.getName() };\n"
 "for (var key in args){\n"
 "cmd[key] = args[key];}\n"
 "var ret = this._db.runCommand( cmd );\n"
 "if ( ! ret.ok ){\n"
 "if (ret.errmsg == \"No matching object found\"){\n"
 "return null;}\n"
 "throw \"findAndModifyFailed failed: \" + tojson( ret.errmsg );}\n"
 "return ret.value;}\n"
 "DBCollection.prototype.renameCollection = function( newName , dropTarget ){\n"
 "return this._db._adminCommand( { renameCollection : this._fullName ,\n"
 "to : this._db._name + \".\" + newName ,\n"
 "dropTarget : dropTarget } )}\n"
 "DBCollection.prototype.validate = function() {\n"
 "var res = this._db.runCommand( { validate: this.getName() } );\n"
 "res.valid = false;\n"
 "var raw = res.result || res.raw;\n"
 "if ( raw ){\n"
 "var str = \"-\" + tojson( raw );\n"
 "res.valid = ! ( str.match( /exception/ ) || str.match( /corrupt/ ) );\n"
 "var p = /lastExtentSize:(\\d+)/;\n"
 "var r = p.exec( str );\n"
 "if ( r ){\n"
 "res.lastExtentSize = Number( r[1] );}}\n"
 "return res;}\n"
 "DBCollection.prototype.getShardVersion = function(){\n"
 "return this._db._adminCommand( { getShardVersion : this._fullName } );}\n"
 "DBCollection.prototype.getIndexes = function(){\n"
 "return this.getDB().getCollection( \"system.indexes\" ).find( { ns : this.getFullName() } ).toArray();}\n"
 "DBCollection.prototype.getIndices = DBCollection.prototype.getIndexes;\n"
 "DBCollection.prototype.getIndexSpecs = DBCollection.prototype.getIndexes;\n"
 "DBCollection.prototype.getIndexKeys = function(){\n"
 "return this.getIndexes().map(\n"
 "function(i){\n"
 "return i.key;}\n"
 ");}\n"
 "DBCollection.prototype.count = function( x ){\n"
 "return this.find( x ).count();}\n"
 "\n"
 "DBCollection.prototype.clean = function() {\n"
 "return this._dbCommand( { clean: this.getName() } );}\n"
 "\n"
 "DBCollection.prototype.dropIndex =  function(index) {\n"
 "assert(index , \"need to specify index to dropIndex\" );\n"
 "if ( ! isString( index ) && isObject( index ) )\n"
 "index = this._genIndexName( index );\n"
 "var res = this._dbCommand( \"deleteIndexes\" ,{ index: index } );\n"
 "this.resetIndexCache();\n"
 "return res;}\n"
 "DBCollection.prototype.copyTo = function( newName ){\n"
 "return this.getDB().eval(\n"
 "function( collName , newName ){\n"
 "var from = db[collName];\n"
 "var to = db[newName];\n"
 "to.ensureIndex( { _id : 1 } );\n"
 "var count = 0;\n"
 "var cursor = from.find();\n"
 "while ( cursor.hasNext() ){\n"
 "var o = cursor.next();\n"
 "count++;\n"
 "to.save( o );}\n"
 "return count;\n"
 "} , this.getName() , newName\n"
 ");}\n"
 "DBCollection.prototype.getCollection = function( subName ){\n"
 "return this._db.getCollection( this._shortName + \".\" + subName );}\n"
 "DBCollection.prototype.stats = function( scale ){\n"
 "return this._db.runCommand( { collstats : this._shortName , scale : scale } );}\n"
 "DBCollection.prototype.dataSize = function(){\n"
 "return this.stats().size;}\n"
 "DBCollection.prototype.storageSize = function(){\n"
 "return this.stats().storageSize;}\n"
 "DBCollection.prototype.totalIndexSize = function( verbose ){\n"
 "var stats = this.stats();\n"
 "if (verbose){\n"
 "for (var ns in stats.indexSizes){\n"
 "print( ns + \"\\t\" + stats.indexSizes[ns] );}}\n"
 "return stats.totalIndexSize;}\n"
 "DBCollection.prototype.totalSize = function(){\n"
 "var total = this.storageSize();\n"
 "var mydb = this._db;\n"
 "var shortName = this._shortName;\n"
 "this.getIndexes().forEach(\n"
 "function( spec ){\n"
 "var coll = mydb.getCollection( shortName + \".$\" + spec.name );\n"
 "var mysize = coll.storageSize();\n"
 "//print( coll + \"\\t\" + mysize + \"\\t\" + tojson( coll.validate() ) );\n"
 "total += coll.dataSize();}\n"
 ");\n"
 "return total;}\n"
 "DBCollection.prototype.convertToCapped = function( bytes ){\n"
 "if ( ! bytes )\n"
 "throw \"have to specify # of bytes\";\n"
 "return this._dbCommand( { convertToCapped : this._shortName , size : bytes } )}\n"
 "DBCollection.prototype.exists = function(){\n"
 "return this._db.system.namespaces.findOne( { name : this._fullName } );}\n"
 "DBCollection.prototype.isCapped = function(){\n"
 "var e = this.exists();\n"
 "return ( e && e.options && e.options.capped ) ? true : false;}\n"
 "DBCollection.prototype.distinct = function( keyString , query ){\n"
 "var res = this._dbCommand( { distinct : this._shortName , key : keyString , query : query || {} } );\n"
 "if ( ! res.ok )\n"
 "throw \"distinct failed: \" + tojson( res );\n"
 "return res.values;}\n"
 "DBCollection.prototype.group = function( params ){\n"
 "params.ns = this._shortName;\n"
 "return this._db.group( params );}\n"
 "DBCollection.prototype.groupcmd = function( params ){\n"
 "params.ns = this._shortName;\n"
 "return this._db.groupcmd( params );}\n"
 "MapReduceResult = function( db , o ){\n"
 "Object.extend( this , o );\n"
 "this._o = o;\n"
 "this._keys = Object.keySet( o );\n"
 "this._db = db;\n"
 "this._coll = this._db.getCollection( this.result );}\n"
 "MapReduceResult.prototype._simpleKeys = function(){\n"
 "return this._o;}\n"
 "MapReduceResult.prototype.find = function(){\n"
 "return DBCollection.prototype.find.apply( this._coll , arguments );}\n"
 "MapReduceResult.prototype.drop = function(){\n"
 "return this._coll.drop();}\n"
 "\n"
 "MapReduceResult.prototype.convertToSingleObject = function(){\n"
 "var z = {};\n"
 "this._coll.find().forEach( function(a){ z[a._id] = a.value; } );\n"
 "return z;}\n"
 "\n"
 "DBCollection.prototype.mapReduce = function( map , reduce , optional ){\n"
 "var c = { mapreduce : this._shortName , map : map , reduce : reduce };\n"
 "if ( optional )\n"
 "Object.extend( c , optional );\n"
 "var raw = this._db.runCommand( c );\n"
 "if ( ! raw.ok )\n"
 "throw \"map reduce failed: \" + tojson( raw );\n"
 "return new MapReduceResult( this._db , raw );}\n"
 "DBCollection.prototype.toString = function(){\n"
 "return this.getFullName();}\n"
 "DBCollection.prototype.toString = function(){\n"
 "return this.getFullName();}\n"
 "DBCollection.prototype.tojson = DBCollection.prototype.toString;\n"
 "DBCollection.prototype.shellPrint = DBCollection.prototype.toString;\n"
 ;

